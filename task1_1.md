这段 C++ 代码实现了一个关于“传扫帚”的问题求解函数：`int findBroomHolder(int n, int time)`，功能是根据人数 `n` 和时间 `time`，确定在某一时刻拿着扫帚的人是谁。下面是详细讲解：

---

### 🧠 问题背景（逻辑设定）：

* 有 `n` 个人站成一排，从 1 到 n 编号。
* 一开始，第 1 个人拿着扫帚。
* 每一秒钟，扫帚传给相邻的人（方向不固定）。
* 扫帚先从 1 传到 n（去程），再从 n 传回 1（回程），反复循环。
* 给定 `n` 和时间 `time`，要求输出第 `time` 秒时拿扫帚的是几号人。

---

### 📄 代码逐行解释：

```cpp
int findBroomHolder(int n, int time) {
```

定义函数 `findBroomHolder`，参数：

* `n`：总人数
* `time`：当前时刻（单位是秒）

---

```cpp
    if (n <= 0 || time < 0) return -1; // 处理无效输入
```

* 输入非法（人数小于等于 0，或时间为负数）直接返回 -1。

---

```cpp
    if (n == 1) return 1; // 只有一个人
```

* 如果只有一个人，无论时间多久，扫帚始终在他手上。

---

```cpp
    int cycle = 2 * (n - 1); // 一个完整来回的周期
```

* 一个完整的“来回”路线：

  * 去程：从 1 到 n（共 n-1 步）
  * 回程：从 n 到 1（共 n-1 步）
  * 所以周期长度是 `2*(n-1)` 秒

---

```cpp
    time %= cycle; // 取模减少计算量
```

* 用 `%` 运算符取模，表示只考虑当前周期内的时间位置。因为周期性行为，超过一个周期的时间可以忽略。

---

```cpp
    if (time < n) return time + 1; // 去程：从1到n
```

* 如果当前时间 `time < n`，表示还在“去程”（从 1 到 n）的阶段。
* 从 1 开始，每秒向后传一个人，所以第 `time` 秒，扫帚在第 `time + 1` 个人手上。

---

```cpp
    else return 2 * n - time - 1; // 回程：从n回到1
```

* 否则，处于“回程”（从 n 回到 1）阶段。
* 回程的规律是每秒向前传，所以位置是按照倒序计算。
* 公式 `2 * n - time - 1` 是推导出来的回程位置公式。

---

### 🧪 示例分析：

假设 `n = 5`，那一个周期长度是 `2 * (5 - 1) = 8` 秒，序列如下（每秒谁拿扫帚）：

* 第 0 秒：1
* 第 1 秒：2
* 第 2 秒：3
* 第 3 秒：4
* 第 4 秒：5
* 第 5 秒：4
* 第 6 秒：3
* 第 7 秒：2
* 第 8 秒：1（下一个周期又开始）

---

### ✅ 总结逻辑结构：

1. 处理异常输入和特殊情况。
2. 利用周期性来简化计算（取模）。
3. 根据 time 所在的阶段（去程或回程），用不同的公式计算扫帚位置。

---

如需可视化或动态模拟，也可以补充图示帮助理解。需要我帮忙画一下也可以。

好的，下面是**扫帚传递过程的可视化图示**，我们以 `n = 5` 为例来说明扫帚在不同时间点的位置（一个完整周期为 8 秒）。

---

### 🧹 传递示意图（n = 5）

```
人编号:   1   2   3   4   5
时间 0:   🧹                    
时间 1:       🧹                
时间 2:           🧹            
时间 3:               🧹        
时间 4:                   🧹    ← 走到尽头，准备返回
时间 5:               🧹        
时间 6:           🧹            
时间 7:       🧹                
时间 8:   🧹                    ← 回到起点，循环开始
```

---

### ⏱️ 对应代码逻辑：

* `cycle = 2 * (n - 1) = 8`
* 时间 `time % cycle` 得到当前周期中的相对时刻
* 判断：

  * `time < n`（即 < 5） ➜ 处于去程 → `time + 1`
  * `time >= n`（即 ≥ 5）➜ 处于回程 → `2 * n - time - 1`

---

### 🧪 举例验证：

假设 `n = 5`：

| 输入 time | time % 8 | 所在阶段 | 返回值             | 实际位置        |
| ------- | -------- | ---- | --------------- | ----------- |
| 0       | 0        | 去程   | 0 + 1 = 1       | ✅ 人1        |
| 3       | 3        | 去程   | 3 + 1 = 4       | ✅ 人4        |
| 4       | 4        | 去程   | 4 + 1 = 5       | ✅ 人5        |
| 5       | 5        | 回程   | 2×5 - 5 - 1 = 4 | ✅ 人4        |
| 7       | 7        | 回程   | 2×5 - 7 - 1 = 2 | ✅ 人2        |
| 8       | 0        | 去程   | 0 + 1 = 1       | ✅ 人1（新周期开始） |

---

如果你希望我用图形生成工具绘制成图片形式（如扫帚动态移动图、箭头标示），也可以告诉我，我可以生成对应的图像。

Конечно! Вот пояснение на русском языке к коду `findBroomHolder` и иллюстрации процесса передачи метлы:

---

Функция `findBroomHolder(int n, int time)` определяет, у кого в данный момент находится метла.

Предположим, что `n` — количество человек, стоящих в ряд, и метла каждую секунду передаётся соседу. Сначала метла передаётся от первого до последнего (прямой путь), затем — обратно от последнего к первому (обратный путь). Такой полный цикл состоит из `2 * (n - 1)` секунд.

Чтобы упростить вычисления, мы берём остаток от деления времени на длину цикла: `time % (2 * (n - 1))`. Это позволяет понять, где находится метла в рамках одного цикла.

* Если `time < n`, значит, метла движется вперёд (от 1 к n). В этом случае номер человека с метлой — `time + 1`.
* Если `time >= n`, метла движется назад (от n к 1). Тогда номер вычисляется по формуле: `2 * n - time - 1`.

На изображении можно видеть, как метла последовательно переходит от человека к человеку: сначала от 1 к 5 (вперёд), затем обратно от 5 к 1. Это движение повторяется циклично.

---

Если нужно, могу帮你 подготовить презентационную讲解稿 или配音文本。
